(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{294:function(n,e,t){"use strict";t.r(e);var r=t(28),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("本文介绍如何在半个小时之内生成调用开放平台接口的签名，及签名加密规则，实现轻松调用百度电商开放平台的相关接口。")]),n._v(" "),t("blockquote",[t("p",[n._v("在签名和验签过程中，如开发者在任何一个环节没有严格按照文档要求操作均会导致此“签名错误”，请认真阅读文档。")])]),n._v(" "),t("h2",{attrs:{id:"特别推荐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特别推荐"}},[n._v("#")]),n._v(" 特别推荐")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("推荐使用 百度电商开放平台的SDK来生成签名。")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://dianshang.baidu.com/platform/doclist/index.html#!/doc/nuomiplus_3_business/moneycourt/settle.md",target:"_blank",rel:"noopener noreferrer"}},[n._v("开放平台SDK使用说明"),t("OutboundLink")],1)])]),n._v(" "),t("li",[t("p",[n._v("如果由于种种原因不愿意使用SDK，也可以参考里面的生成签名的代码，事半功倍，不用再次开发生成签名代码。")])]),n._v(" "),t("li",[t("p",[n._v("SDK的demo中有完成调用开放平台接口的完整示例。")])])]),n._v(" "),t("h2",{attrs:{id:"签名计算基本设定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#签名计算基本设定"}},[n._v("#")]),n._v(" 签名计算基本设定")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("百度电商开放平台的所有接口中的所有参数的编码都是UTF-8，所以跟平台交互或者计算签名的时候字符编码都是UTF-8，"),t("br"),n._v("\n暂时没有支持其他编码的打算，请开发者自行对于自己的代码编码进行转换")])]),n._v(" "),t("li",[t("p",[n._v("您如果不清楚的自己请求参数的编码，PHP可以使用mb_detect_encoding函数进行检测编码,"),t("br"),n._v("\n因Java没有直接的函数可以考虑使用以下代码进行检测")])])]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('String encode = "UTF-8"; \n\nSystem.out.println( str.equals( new String(str.getBytes(encode),encode) );\n\n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[n._v("请求接口的参数列表均为键值对，键名为字符串，键值也必须为字符串。")])]),n._v(" "),t("li",[t("p",[n._v("键值中如果为复杂数据类型，比如结构体. 数组. 对象都必须先转化成为字符串。")])]),n._v(" "),t("li",[t("p",[n._v("建议键名中有复杂数据类型，PHP先转换成为数组array，Java先转换成为HashMap，因为平台现在对于参数的形式，"),t("br"),n._v("\n复杂只支持Json类型，PHP的array类型和Java的HashMap类型都可以很方便转换成Json")])]),n._v(" "),t("li",[t("p",[n._v("PHP中对于键名为数组情况，需要对数组中汉字进行urlencode函数进行编码，之后再json_encode。")])])]),n._v(" "),t("h2",{attrs:{id:"筛选进行签名的参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#筛选进行签名的参数"}},[n._v("#")]),n._v(" 筛选进行签名的参数")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("参数名为sign. sign_type参数不需要参与签名。")])]),n._v(" "),t("li",[t("p",[n._v("建议业务方也不需要在参数列表中进行签名参数之前，也不要有这样容易造成签名错误的参数")])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("支付回调验签中全部参数签名是对平台的所有POST参数进行签名，空值参数同样要参与签名，如不参与签名，会导致验签不通过，如果商户URL里包含GET类型参数，不会参与签名。")])])])]),n._v(" "),t("h2",{attrs:{id:"对参数进行排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对参数进行排序"}},[n._v("#")]),n._v(" 对参数进行排序")]),n._v(" "),t("p",[n._v("将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("PHP采用ksort函数进行排序。")])]),n._v(" "),t("li",[t("p",[n._v("Java先初始化ArrayList，然后使用sort方法进行排序。")])])]),n._v(" "),t("h2",{attrs:{id:"对参数进行拼接组成待签名字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对参数进行拼接组成待签名字符串"}},[n._v("#")]),n._v(" 对参数进行拼接组成待签名字符串")]),n._v(" "),t("ol",[t("li",[n._v("使用 = 和 & 将参数连接起来，将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&字符连接起来，此时生成的字符串为待签名字符串。")])]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("orderId=800020199&tpOrderId=33330020199&status=2&unitPrice=800&count=2&payMoney=1200&promoMoney=100&hbMoney=100&hbBalanceMoney=100&giftCardMoney=100&dealId=7423328&payTime=1463037529&payType=9101&partnerId=1000000003&promoDetail={}\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("将待签名字符串和业务方私钥带入SHA1算法中得出sign")])]),n._v(" "),t("p",[n._v("组成的待签名字符串为：")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("count=2&dealId=7423328&giftCardMoney=100&hbBalanceMoney=100&hbMoney=100&orderId=800020199&partnerId=1000000003&payMoney=1200&payTime=1463037529&payType=9101&promoDetail={}&promoMoney=100&status=2&tpOrderId=33330020199&unitPrice=800\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[n._v("使用各自语言对应的SHA1WithRSA签名生成函数（如php: openssl_sign），传入待签名字符串. 业务方私钥，由SHA1算法中得出sign，然后base64encode。")])]),n._v(" "),t("p",[n._v("示例生成的签名为：")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("rsaSign=Gzu1RT2toJSDthcLPG1ZWROI3jzvxFtO7yCPUqMT3L7cmnARncm5IIIQ6x+7S/02zWxr5FC9945WFSurO9kepVbU7YS6Lh9SEVQhvTO0YKG7TlLFTpH3Ik7JeHQalAKXYe/jNREDpHmTF9Jrq/wABeZGYXJn1M75A37h9zUt+kw=\n")])])]),t("p",[n._v("完整的请求URL为：")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("https://xxx.tpbusiness.xxx/SyncPayInfo?orderId=800020199&tpOrderId=33330020199&status=2&unitPrice=800&count=2&payMoney=1200&promoMoney=100&hbMoney=100&hbBalanceMoney=100&giftCardMoney=100&dealId=7423328&payTime=1463037529&payType=9101&partnerId=1000000003&promoDetail={}&rsaSign=Gzu1RT2toJSDthcLPG1ZWROI3jzvxFtO7yCPUqMT3L7cmnARncm5IIIQ6x+7S/02zWxr5FC9945WFSurO9kepVbU7YS6Lh9SEVQhvTO0YKG7TlLFTpH3Ik7JeHQalAKXYe/jNREDpHmTF9Jrq/wABeZGYXJn1M75A37h9zUt+kw=\n")])])]),t("h2",{attrs:{id:"php相关的签名生成的参考代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#php相关的签名生成的参考代码"}},[n._v("#")]),n._v(" PHP相关的签名生成的参考代码")]),n._v(" "),t("ol",[t("li",[n._v("PHP生成签名的工具类")])]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<?php\n/**\n * API入参静态检查类\n * 可以对API的参数类型. 长度. 最大值等进行校验\n *\n **/\nclass NuomiRsaSign\n{\n\n    /**\n     * @desc 私钥生成签名字符串\n     * @param array $assocArr\n     * @param $rsaPriKeyStr\n     * @return bool|string\n     * @throws Exception\n     */\n    public static function genSignWithRsa(array $assocArr, $rsaPriKeyStr)\n    {\n        $sign = '';\n        if (empty($rsaPriKeyStr) || empty($assocArr)) {\n            return $sign;\n        }\n\n        if (!function_exists('openssl_pkey_get_private') || !function_exists('openssl_sign')) {\n            throw new Exception(\"openssl扩展不存在\");\n        }\n\n        $priKey = openssl_pkey_get_private($rsaPriKeyStr);\n\n        if (isset($assocArr['sign'])) {\n            unset($assocArr['sign']);\n        }\n\n        ksort($assocArr); //按字母升序排序\n\n        $parts = array();\n        foreach ($assocArr as $k => $v) {\n            $parts[] = $k . '=' . $v;\n        }\n        $str = implode('&', $parts);\n        openssl_sign($str, $sign, $priKey);\n        openssl_free_key($priKey);\n\n        return base64_encode($sign);\n    }\n\n    /**\n     * @desc 公钥校验签名\n     * @param array $assocArr\n     * @param $rsaPubKeyStr\n     * @return bool\n     * @throws Exception\n     */\n    public static function checkSignWithRsa(array $assocArr, $rsaPubKeyStr)\n    {\n        if (!isset($assocArr['sign']) || empty($assocArr) || empty($rsaPubKeyStr)) {\n            return false;\n        }\n\n        if (!function_exists('openssl_pkey_get_public') || !function_exists('openssl_verify')) {\n            throw new Exception(\"openssl扩展不存在\");\n        }\n\n        $sign = $assocArr['sign'];\n        unset($assocArr['sign']);\n\n        if (empty($assocArr)) {\n            return false;\n        }\n        ksort($assocArr); //按字母升序排序\n        $parts = array();\n        foreach ($assocArr as $k => $v) {\n            $parts[] = $k . '=' . $v;\n        }\n        $str = implode('&', $parts);\n\n        $sign = base64_decode($sign);\n        $pubKey = openssl_pkey_get_public($rsaPubKeyStr);\n        $result = (bool)openssl_verify($str, $sign, $pubKey);\n        openssl_free_key($pubKey);\n\n        return $result;\n    }\n\n}\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("调用PHP签名生成类生成签名的参考代码")])]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n/**\n * 第一部分：从申请的私钥文件路径中读取出私钥的内容\n * @notice1: 私钥文件可以从任意存储介质中读取 \n */\n\n$rsaPriviateKeyFilePath = 'rsa/rsa_private_key.pem';\n\n$rsaPrivateKey = file_get_contents($rsaPriviateKeyFilePath);\n\n\n/**\n * 第二部分：使用参数计算签名\n */\n\n$requestApiParamsArr = array('key1'=>'value1','key2'=>'value2');\n\n$rsaSign = NuomiRsaSign::genSignWithRsa( $requestApiParamsArr ,$rsaPrivateKey);\n\n\n")])])]),t("h2",{attrs:{id:"java相关的签名生成的参考代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java相关的签名生成的参考代码"}},[n._v("#")]),n._v(" JAVA相关的签名生成的参考代码")]),n._v(" "),t("ol",[t("li",[n._v("JAVA生成签名的工具类")])]),n._v(" "),t("p",[n._v("com.nuomi.common.* 相关文件可以在开放平台的下载中找到")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n * nuomi.com Inc.\n * Copyright (c) 2004-2018 All Rights Reserved.\n */\n\npackage com.nuomi.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\n\nimport com.nuomi.common.NuomiApiException;\nimport com.nuomi.common.NuomiConstants;\nimport com.nuomi.util.codec.Base64;\n\n/**\n * 签名工具类\n * 目前只支持rsa方式  不支持rsa2\n */\npublic class NuomiSignature {\n\n\n    /**\n     * 获取签名\n     *\n     * @param sortedParams 排序后的参数\n     * @param privateKey   私钥\n     * @return 返回签名后的字符串\n     * @throws NuomiApiException\n     */\n    public static String genSignWithRsa(Map<String, String> sortedParams, String privateKey) throws NuomiApiException {\n        String sortedParamsContent = getSignContent(sortedParams);\n        return rsaSign(sortedParamsContent, privateKey, NuomiConstants.CHARSET_UTF8);\n    }\n\n    /**\n     * 签名验证\n     *\n     * @param sortedParams\n     * @param pubKey\n     * @param sign\n     * @return\n     * @throws NuomiApiException\n     */\n    public static boolean checkSignWithRsa(Map<String, String> sortedParams, String pubKey, String sign)\n            throws NuomiApiException {\n        String sortedParamsContent = getSignContent(sortedParams);\n        return doCheck(sortedParamsContent, sign, pubKey, NuomiConstants.CHARSET_UTF8);\n    }\n\n    /**\n     * @param sortedParams 已经排序的字符串\n     * @return 返回签名后的字符串\n     */\n    public static String getSignContent(Map<String, String> sortedParams) {\n        StringBuffer content = new StringBuffer();\n        List<String> keys = new ArrayList<String>(sortedParams.keySet());\n        Collections.sort(keys);\n        int index = 0;\n        for (int i = 0; i < keys.size(); i++) {\n            String key = keys.get(i);\n            String value = sortedParams.get(key);\n            content.append((index == 0 ? "" : "&") + key + "=" + value);\n            index++;\n            \n        }\n        return content.toString();\n    }\n\n\n    /**\n     * sha1WithRsa 加签\n     *\n     * @param content    需要加密的字符串\n     * @param privateKey 私钥\n     * @param charset    字符编码类型  如：utf8\n     * @return\n     * @throws NuomiApiException\n     */\n    public static String rsaSign(String content, String privateKey,\n                                 String charset) throws NuomiApiException {\n        try {\n            PrivateKey priKey = getPrivateKeyFromPKCS8(NuomiConstants.SIGN_TYPE_RSA,\n                    new ByteArrayInputStream(privateKey.getBytes()));\n\n            java.security.Signature signature = java.security.Signature\n                    .getInstance(NuomiConstants.SIGN_ALGORITHMS);\n\n            signature.initSign(priKey);\n\n            if (StringUtils.isEmpty(charset)) {\n                signature.update(content.getBytes());\n            } else {\n                signature.update(content.getBytes(charset));\n            }\n\n            byte[] signed = signature.sign();\n\n            return new String(Base64.encodeBase64(signed));\n        } catch (InvalidKeySpecException ie) {\n            throw new NuomiApiException("RSA私钥格式不正确，请检查是否正确配置了PKCS8格式的私钥", ie);\n        } catch (Exception e) {\n            throw new NuomiApiException("RSAcontent = " + content + "; charset = " + charset, e);\n        }\n    }\n\n\n    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm,\n                                                    InputStream ins) throws Exception {\n        if (ins == null || StringUtils.isEmpty(algorithm)) {\n            return null;\n        }\n\n        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n\n        byte[] encodedKey = StreamUtil.readText(ins).getBytes();\n\n        encodedKey = Base64.decodeBase64(encodedKey);\n\n        return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));\n    }\n\n    /**\n     * RSA验签名检查\n     *\n     * @param content   待签名数据\n     * @param sign      签名值\n     * @param publicKey 分配给开发商公钥\n     * @param encode    字符集编码\n     * @return 布尔值\n     * @throws NuomiApiException\n     */\n    private static boolean doCheck(String content, String sign, String publicKey, String encode)\n            throws NuomiApiException {\n        try {\n            KeyFactory keyFactory = KeyFactory.getInstance(NuomiConstants.SIGN_TYPE_RSA);\n            byte[] bytes = publicKey.getBytes();\n            byte[] encodedKey = Base64.decodeBase64(bytes);\n            PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n            java.security.Signature signature = java.security.Signature.getInstance(NuomiConstants.SIGN_ALGORITHMS);\n\n            signature.initVerify(pubKey);\n            signature.update(content.getBytes(encode));\n\n            boolean bverify = signature.verify(Base64.decodeBase64(sign.getBytes()));\n            return bverify;\n\n        } catch (Exception e) {\n            throw new NuomiApiException("RSA私钥格式不正确，请检查是否正确配置了PKCS8格式的私钥", e);\n        }\n    }\n\n}\n\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("调用JAVA签名生成类生成签名的参考代码")])]),n._v(" "),t("p",[n._v("com.nuomi.common.* 相关文件可以在开放平台的下载中找到")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n * 第一部分：赋值私钥\n * @notice1:因为JAVA中的字节流. 字符流. 双字符流等概念非常复杂，建议使用常量存储私钥文件\n * @notice2:私钥文件为不换行且不带私钥开头和结尾的字符串\n */\n\nString PRIVATE_KEY = "MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAM8vojS3eWYEnB0Xl73+8+D/xdzeWTvbZc0SPO6nKmm3WxBYX/fFI6S7DhhK0QAUKjbSD4hDyqLkgy8azi8ETvYSYIoTjdR55nNklCNQ9RAtPVeuAAFzN0h2DmfY3/F7FsUFg9Qd/9YaGpU+CEnZDThjvWxBg22HvlN09xKfAYltAgMBAAECgYAr8wDHifv4hhXPngeUSBbXran9NjVbmyi3HZ1LSq6WikyI5RZGas0qznso8AXxrFVgF6Mv1qGPeEXToi4GjzVoX5ocfUoSlqE5xmhdfmc4aqKz/BlncCVlgNnlQEp5oHpGiIzVEpabC4OiBMRAhi/Brvu14GOUkP1VEZmfuCQCCQJBAPKytmmzznsDaiO15AeorPi/nUNDMLoOoiFwZgUxXWW7PI+uZq1ja5NpMjuRu3eVt3dFexB7x+ZnBb9tWTGQtDMCQQDaiqc4vR1eiSpVMf+rB6+Xbj+dDrtoTaH66YrBKXE5tbWPlsm1MWWpmDREFntU+f3yAQqjgVAtCULmp8odkCvfAkEAge9aJ+dDIarnVW0ZQ1x0Fs0Hli5P1Rzmgn6ZsCgIt+Fxf/9AK44x1v8YDLpuIoz+Z5XEWEPc9yaq9hzGBvpQ7wJAErDLDnI2IdCvWyv0hscYgGYAcMlCw+/ny5LPuCd4NIxS493skF+SJ0gKKEyX7bOXwWvPYh58Ie3p19o/0flzlwJBAJ8Ut/aPdzIFIlvR8BdQ7O/6BCf2490vWjNrzu+TOWCEeEM4IMfgXSg3chhExJg8TXwU0IbiB5fnDeIreWbPPWY=";\n        \n   \n/**\n * 第二部分：计算签名\n */\n/**\n * 1.通过方法获取到所有需要需要参与签名的参数HashMap\n */\nHashMap apiParams = new HashMap();\n\n        \n/**\n * 2.从常量中读取privateKey,然后计算RSA签名\n */\nString rsaSign = NuomiSignature.genSignWithRsa(apiParams,NuomiConstants.PRIVATE_KEY);\n\n')])])]),t("h2",{attrs:{id:"将平台公钥转换成正确格式的公钥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将平台公钥转换成正确格式的公钥"}},[n._v("#")]),n._v(" 将平台公钥转换成正确格式的公钥")]),n._v(" "),t("blockquote",[t("p",[n._v("将应用详情页的平台公钥和应用公钥（这2个公钥是没有开始. 结尾标示和换行符的）转换成正确的公钥格式")])]),n._v(" "),t("p",[n._v("1.PHP代码")]),n._v(" "),t("CodeTabContent",{attrs:{name:"TEXT"}},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    /**\n     * @desc 密钥由字符串（不换行）转为PEM格式\n     * @param $rsaKeyStr\n     * @param int $keyType 0:公钥，1:私钥\n     * @return string\n     * @throws SF_Exception_InternalException\n     */\n    public static function convertRSAKeyStr2Pem($rsaKeyStr, $keyType = 0)\n    {\n        $rsaKeyPem = '';\n\n        $beginPublicKey   = '-----BEGIN PUBLIC KEY-----';\n        $endPublicKey     = '-----END PUBLIC KEY-----';\n        $beginPrivateKey  = '-----BEGIN PRIVATE KEY-----';\n        $endPrivateKey    = '-----END PRIVATE KEY-----';\n\n        $keyPrefix = $keyType ? $beginPrivateKey : $beginPublicKey;\n        $keySuffix = $keyType ? $endPrivateKey : $endPublicKey;\n\n        $rsaKeyPem .= $keyPrefix. \"\\n\";\n        $rsaKeyPem .= wordwrap($rsaKeyStr, 64, \"\\n\", true) . \"\\n\";\n        $rsaKeyPem .= $keySuffix;\n\n        if(!function_exists('openssl_pkey_get_public') || !function_exists('openssl_pkey_get_private')){\n            return false;\n        }\n\n        if($keyType == 0 && false == openssl_pkey_get_public($rsaKeyPem)){\n            return false;\n        }\n\n        if($keyType == 1 && false == openssl_pkey_get_private($rsaKeyPem)){\n            return false;\n        }\n\n        return $rsaKeyPem;\n    }\n")])])])],1)}),[],!1,null,null,null);e.default=a.exports}}]);